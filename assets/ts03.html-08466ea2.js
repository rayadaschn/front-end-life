const n=JSON.parse('{"key":"v-f4a7a860","path":"/JavaScript/TS/ts03.html","title":"再论 ts 体操","lang":"zh-CN","frontmatter":{"title":"再论 ts 体操","icon":"javascript","date":"2025-05-06T00:00:00.000Z","category":["javascript"],"tag":["typescript"]},"headers":[{"level":2,"title":"ts 为什么被称为「类型体操」?","slug":"ts-为什么被称为「类型体操」","link":"#ts-为什么被称为「类型体操」","children":[]},{"level":2,"title":"ts 体操套路","slug":"ts-体操套路","link":"#ts-体操套路","children":[{"level":3,"title":"1. 条件类型（extends ? :）","slug":"_1-条件类型-extends","link":"#_1-条件类型-extends","children":[]},{"level":3,"title":"2. 类型推断 infer","slug":"_2-类型推断-infer","link":"#_2-类型推断-infer","children":[]},{"level":3,"title":"3. 递归类型","slug":"_3-递归类型","link":"#_3-递归类型","children":[]},{"level":3,"title":"4. 联合类型分发特性","slug":"_4-联合类型分发特性","link":"#_4-联合类型分发特性","children":[]},{"level":3,"title":"5. 字符串模板类型","slug":"_5-字符串模板类型","link":"#_5-字符串模板类型","children":[]},{"level":3,"title":"6. 映射类型","slug":"_6-映射类型","link":"#_6-映射类型","children":[]},{"level":3,"title":"7. keyof、in、typeof 等关键字","slug":"_7-keyof、in、typeof-等关键字","link":"#_7-keyof、in、typeof-等关键字","children":[]},{"level":3,"title":"8. 分布式条件 + 递归的组合拳","slug":"_8-分布式条件-递归的组合拳","link":"#_8-分布式条件-递归的组合拳","children":[]}]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"createdTime":1746540748000,"updatedTime":1746540748000,"contributors":[{"name":"rayadaschn","email":"115447518+rayadaschn@users.noreply.github.com","commits":1}]},"readingTime":{"minutes":3.44,"words":1031},"filePathRelative":"JavaScript/TS/ts03.md","localizedDate":"2025年5月6日","excerpt":"<p>长期以来对于 ts 一直停留在「入门」阶段，实际并不理解，ts 为什么在社区中被称为「类型体操」。本文就 ts 类型体操进行梳理，以作回顾。</p>\\n<h2> ts 为什么被称为「类型体操」?</h2>\\n<p>这其实是因为 js 这门语言过于灵活导致的，ts 作为 js 的超集，旨在编译过程中做类型检查，并不会改变 js 的语法。我们可以先看一下其它静态语言的特点：</p>\\n<ol>\\n<li>\\n<p>简单增加类型系统</p>\\n<p>仅仅对定义的变量、函数和类等进行类型声明。类型不匹配时会报错。（这也是笔者此前简单使用 ts 的途径）这种类型系统，过于死板了。比如同一个加法函数，对整数和浮点数需要分别声明,这里以 c++ 为例：</p>\\n<div class=\\"language-c++ line-numbers-mode\\" data-ext=\\"c++\\"><pre class=\\"language-c++\\"><code>int&nbsp;add(int&nbsp;a,&nbsp;int&nbsp;b)&nbsp;{\\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;a&nbsp;+&nbsp;b;\\n}\\n\\ndouble&nbsp;add(double&nbsp;a,&nbsp;double&nbsp;b)&nbsp;{\\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;a&nbsp;+&nbsp;b;\\n}\\n</code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div></li>\\n<li>\\n<p>支持泛型的类型系统</p>\\n<p>ts 中也有泛型，泛型旨在通过一种通用的类型，来减少重复的代码。这里不过多介绍。</p>\\n<div class=\\"language-c++ line-numbers-mode\\" data-ext=\\"c++\\"><pre class=\\"language-c++\\"><code>T&nbsp;add&lt;T&gt;(T&nbsp;a,&nbsp;T&nbsp;b)&nbsp;{\\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;a&nbsp;+&nbsp;b;\\n}\\n\\nadd(1,2);\\nadd(1.111, 2.2222);\\n</code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div><p>java 就是这种类型系统，但是这对于 js 来说还是不够。因为 在 java 中对象都是通过类 new 出来的，但 js 可以凭空创建对象，并且在 ts 中，有时还需要对泛型 T 进行一些逻辑处理。由此诞生了 ts 这种「支持类型编程的类型系统」</p>\\n</li>\\n<li>\\n<p>支持类型编程的类型系统</p>\\n<p>在 ts 中，经常能看到<strong>对传入的类型参数（泛型）做各种逻辑运算，产生新的类型，这就是类型编程。</strong></p>\\n<p>比如下面这个类型体操题目：实现一个类型 <code>Flatten&lt;T&gt;</code>，把嵌套的数组类型展开成一个一维数组：</p>\\n<div class=\\"language-typescript line-numbers-mode\\" data-ext=\\"ts\\"><pre class=\\"language-typescript\\"><code><span class=\\"token keyword\\">type</span> <span class=\\"token class-name\\">Flatten<span class=\\"token operator\\">&lt;</span><span class=\\"token constant\\">T</span><span class=\\"token operator\\">&gt;</span></span> <span class=\\"token operator\\">=</span> <span class=\\"token constant\\">T</span> <span class=\\"token keyword\\">extends</span> <span class=\\"token punctuation\\">[</span><span class=\\"token keyword\\">infer</span> First<span class=\\"token punctuation\\">,</span> <span class=\\"token operator\\">...</span><span class=\\"token keyword\\">infer</span> Rest<span class=\\"token punctuation\\">]</span>\\n  <span class=\\"token operator\\">?</span> <span class=\\"token punctuation\\">[</span><span class=\\"token operator\\">...</span>Flatten<span class=\\"token operator\\">&lt;</span>First<span class=\\"token operator\\">&gt;</span><span class=\\"token punctuation\\">,</span> <span class=\\"token operator\\">...</span>Flatten<span class=\\"token operator\\">&lt;</span>Rest<span class=\\"token operator\\">&gt;</span><span class=\\"token punctuation\\">]</span>\\n  <span class=\\"token operator\\">:</span> <span class=\\"token punctuation\\">[</span><span class=\\"token constant\\">T</span><span class=\\"token punctuation\\">]</span>\\n\\n<span class=\\"token keyword\\">type</span> <span class=\\"token class-name\\">Result</span> <span class=\\"token operator\\">=</span> Flatten<span class=\\"token operator\\">&lt;</span><span class=\\"token punctuation\\">[</span><span class=\\"token number\\">1</span><span class=\\"token punctuation\\">,</span> <span class=\\"token punctuation\\">[</span><span class=\\"token number\\">2</span><span class=\\"token punctuation\\">,</span> <span class=\\"token punctuation\\">[</span><span class=\\"token number\\">3</span><span class=\\"token punctuation\\">,</span> <span class=\\"token number\\">4</span><span class=\\"token punctuation\\">]</span><span class=\\"token punctuation\\">]</span><span class=\\"token punctuation\\">,</span> <span class=\\"token number\\">5</span><span class=\\"token punctuation\\">]</span><span class=\\"token operator\\">&gt;</span>\\n<span class=\\"token comment\\">// 结果是 [1, 2, 3, 4, 5]</span>\\n</code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div><p>这就像在类型层面实现了一个“数组扁平化”，完全不依赖 JS 运行逻辑，全靠类型推导实现，非常绕脑，但也很优雅。</p>\\n</li>\\n</ol>"}');export{n as data};
