import{_ as c,X as d,Z as t,$ as i,V as n,W as s,F as a,Y as r}from"./framework-2eee3422.js";const p={},e=d,o=t,u=a,k=i,m=r,h=n,g=s,b=e("h1",{id:"docker-速通",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#docker-速通","aria-hidden":"true"},"#"),o(" Docker 速通")],-1),_=e("p",null,"没看懂的官网简介：“Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app），更重要的是容器性能开销极低。”",-1),v=e("p",null,[e("strong",null,"通俗理解：Docker 可以通过将应用程序和相关依赖项封装到容器中，实现在不同环境下运行相同的应用程序。这使得开发人员可以在本地创建和测试应用程序，并将其打包成 Docker 镜像并将其部署到测试、预发布和生产环境中。 Docker 还支持使用不同的镜像标签来轻松切换不同版本的应用程序，并且可以使用容器编排工具（如 Docker Compose 和 Kubernetes）来自动化部署和管理多个容器。这些特性使 Docker 成为一种流行的解决方案，可以帮助团队快速有效地构建、测试和部署应用程序。")],-1),D=e("blockquote",null,[e("p",null,"“将应用程序和相关依赖项封装到容器中” 的意思是："),e("p",null,"将依赖项封装到容器中是指将应用程序所需要的所有依赖项（如软件包、库、配置文件等）打包成一个独立的容器镜像。这个镜像中包含了应用程序所需的所有环境配置和代码，可以在任何支持 Docker 的环境中运行，从而确保应用程序在不同的机器或者环境下有一致的运行表现。因此，将依赖项封装到容器中，可以避免各种环境之间的差异性所带来的问题，例如不同操作系统、不同版本的软件库等，极大地提高了应用程序的可移植性和部署效率。")],-1),x=e("h2",{id:"前置知识",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#前置知识","aria-hidden":"true"},"#"),o(" 前置知识")],-1),f=e("strong",null,"systemctl",-1),I={href:"https://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html",target:"_blank",rel:"noopener noreferrer"},y=e("strong",null,"ctl的意思是control，也就是控制",-1),N=m(`<p><strong>Docker</strong> 是什么? 为了解决运行环境和配置问题的软件容器，方便做持续集成并有助于整体发布的容器虚拟化技术。</p><h2 id="安装及常用命令" tabindex="-1"><a class="header-anchor" href="#安装及常用命令" aria-hidden="true">#</a> 安装及常用命令</h2><p>值得注意的是，Docker 并非是一个通用的容器工具，它依赖于已存在并运行的 Linux 内核环境。因此，Docker 必须部署在 Linux 内核的系统上。</p><p>本地开发端 Mac 安装：</p><p>推荐使用 Brew，简化安装过程、升级版本便利，还能确保环境的干净和可重复性。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$: brew <span class="token function">install</span> <span class="token function">docker</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>服务器端 CentOS 安装：</p><ol><li>安装： <code>yum -y install docker-ce docker-ce-cli containerd.io </code></li><li>启动 Docker： <code>systemctl start docker</code></li><li>测试：<code>docker version</code></li><li>卸载： <ul><li><code>systemctl stop docker</code></li><li><code>yum remove docker-ce docker-ce-cli containerd.io</code></li><li><code>rm -rf /var/lib/docker</code></li><li><code>rm -rf /var/lib/containerd</code></li></ul></li></ol><p>容器常用指令：</p><p>总体步骤：</p><ol><li>搜索镜像：<strong>docker search tomcat</strong></li><li>拉取镜像</li><li>查看镜像</li><li>启动镜像</li><li>停止镜像</li><li>移除容器</li></ol><p>有镜像才能创建容器，下载镜像相当于下拉包：</p><ul><li>下载 CentOS：<code>docker pull centos</code></li><li>下载 Ubuntu：<code>docker pull ubuntu</code></li></ul><ol><li><p>新建并启动容器：<code>docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</code></p><ul><li><p>OPTIONS 说明 有些是一个 “<code>-</code>”有些是俩个“<code>--</code>”；</p></li><li><p><code>--name</code> 容器新名字，为容器指定一个名称；</p></li><li><p><code>-d</code>：后台运行容器 ID，即启动后台守护式容器；</p></li><li><p><code>-i</code>：表示将标准输入 (stdin) 绑定到容器的交互式 shell。这个选项可以让你将本地计算机上的文件传递给容器，或者从容器中提取文件到本地计算机。，通常与“<code>-t</code>” 同时使用；</p></li><li><p><code>-t</code>：在创建容器时为其分配一个伪终端 (pseudo-tty)，生成可交互的 shell 环境。这个选项可以让你在容器内部执行命令，并且可以像在本地终端一样与容器交互。通常与“<code>-i</code>”同时使用；</p></li><li><p><code>-P</code>：大写 P 为随即端口映射；</p></li><li><p><code>-p</code>：小写 p 为指定端口。</p></li></ul><blockquote><p><code>-it</code> 与 <code>-d</code> 的区别：</p><p><code>docker run -it ubuntu bash</code> ： 前台命令行交互；</p><p><code>docker run -d nginx</code>：容器后台运行。</p></blockquote></li><li><p>列出当前所有正在运行的容器：<code>docker ps [OPTIONS]</code></p><ul><li><code>-a</code>：列出当前所有正在运行的容器 + 历史上运行过的；</li><li><code>-l</code>：显示最近创建的容器；</li><li><code>-n</code>：显示最近 n 个创建的容器；</li><li><code>-q</code>：静默模式，只显示编号。</li></ul></li><li><p>退出容器：</p><ul><li>exit：run 进去容器，exit 退出，容器停止；</li><li>ctrl + p + q：run 进去容器， ctrl + p + q 退出，容器不停止。</li></ul></li><li><p>启动已经停止运行的容器：<code>docker start &lt;容器 ID 或容器名&gt;</code></p></li><li><p>重启容器：<code>docker restart &lt;容器 ID 或容器名&gt;</code></p></li><li><p>停止容器：<code>docker stop &lt;容器 ID 或容器名&gt;</code></p></li><li><p>强制停止容器：<code>docker kill &lt;容器 ID 或容器名&gt;</code></p></li><li><p>删除已停止的容器：<code>docker rm &lt;容器 ID&gt;</code></p></li><li><p>查看容器日志：<code>docker logs &lt;容器 ID&gt;</code></p></li><li><p>查看容器内运行的进程：<code>docker top &lt;容器 ID&gt;</code></p></li><li><p>查看容器内部细节：<code>docker inspect &lt;容器 ID&gt;</code></p></li><li><p>进入正在运行的容器并以命令行交互：<code>docker exec -it &lt;容器 ID&gt; bashShell</code></p></li><li><p>从容器内部拷贝文件到主机上：<code>docker cp &lt;容器 ID&gt; &lt;目的主机路径&gt;</code></p></li><li><p>导入容器：<code>cat &lt;文件名.文件后缀&gt; | docker import - &lt;镜像用户/镜像名:镜像版本号&gt;</code></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$: <span class="token function">cat</span> README.md <span class="token operator">|</span> <span class="token function">docker</span> <span class="token function">import</span> - huy/ubuntu:2.0
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>导出容器：<code>docker export &lt;容器 ID&gt; &gt; &lt;文件名.文件后缀&gt;</code></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$: <span class="token function">docker</span> <span class="token builtin class-name">export</span> <span class="token number">123456</span> <span class="token operator">&gt;</span> README.md
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>容器卷同宿主机连接：<code>docker run -it --privileged=true -v &lt;/宿主机绝对路径目录:/容器目录&gt; &lt;镜像名或 ID&gt;:&lt;版本号&gt;</code></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$: <span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--privileged</span><span class="token operator">=</span>true <span class="token parameter variable">-v</span> /mydocker/u:/tmp ubuntu
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ol>`,14);function E(O,S){const l=u("ExternalLinkIcon");return h(),g("div",null,[b,_,v,D,x,e("p",null,[f,o(" 指令，可以查阅《"),e("a",I,[o("Systemd 入门教程：命令篇"),k(l)]),o("》。system 是一个 systemd 工具，主要负责控制 systemd 系统和服务管理器。诸如 timedatectl 等以 ctl 结尾的命令，其中 "),y,o("。")]),N])}const q=c(p,[["render",E],["__file","docker01.html.vue"]]);export{q as default};
