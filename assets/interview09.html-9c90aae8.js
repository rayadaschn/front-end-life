import{_ as e,X as a,Y as r,$ as i}from"./framework-97fa2d96.js";const h={},d=i,o=a,t=r,n=d('<p>框架类面试主要考察三个方面:</p><ul><li>框架的使用(基本使用, 高级特性, 周边插件)</li><li>框架的原理(基本原理的了解, 热门技术的深度和全面性)</li><li>框架的实际应用,即设计能力(组件结构和数据结构)</li></ul><h2 id="基本使用" tabindex="-1"><a class="header-anchor" href="#基本使用" aria-hidden="true">#</a> 基本使用</h2><h2 id="框架原理" tabindex="-1"><a class="header-anchor" href="#框架原理" aria-hidden="true">#</a> 框架原理</h2><h3 id="_1-什么是虚拟-dom" tabindex="-1"><a class="header-anchor" href="#_1-什么是虚拟-dom" aria-hidden="true">#</a> 1. 什么是虚拟 DOM？</h3><p>虚拟 DOM（Virtual DOM）是一种模拟真实 DOM 的技术，它把浏览器页面渲染时需要进行的 DOM 操作模拟成 JavaScript 对象，这样就可以在运行时更高效地更新 DOM。虚拟 DOM 的优点是可以在较短的时间内虚拟地表示真实 DOM，并且可以方便地实现跨平台和跨浏览器。</p><h3 id="_2-v-show-和-v-if-有什么区别" tabindex="-1"><a class="header-anchor" href="#_2-v-show-和-v-if-有什么区别" aria-hidden="true">#</a> 2. v-show 和 v-if 有什么区别？</h3><p>v-show 指令是通过设置元素的 display 属性来控制元素是否显示，而 v-if 指令是通过控制元素在文档中的存在性来控制元素的显示和隐藏。</p><p>v-show 指令在初始渲染时就会创建元素，而 v-if 指令在条件第一次满足时才会创建元素，在条件第二次满足时会销毁元素，因此 v-if 指令比 v-show 指令具有更高的性能。</p><p>v-show 指令在条件改变时，并不会去操作 DOM，而 v-if 指令在条件改变时，会根据条件的改变去操作 DOM。</p><h3 id="_3-v-for-和-v-if-一起使用有什么问题" tabindex="-1"><a class="header-anchor" href="#_3-v-for-和-v-if-一起使用有什么问题" aria-hidden="true">#</a> 3. v-for 和 v-if 一起使用有什么问题？</h3><p>v-for 指令和 v-if 指令不能同时使用，因为 v-for 指令会遍历数组或对象，而 v-if 指令会从初始渲染时就创建元素，因此 v-for 指令和 v-if 指令不能同时使用。</p><h3 id="_4-为什么-v-for-循环的-key-需要唯一" tabindex="-1"><a class="header-anchor" href="#_4-为什么-v-for-循环的-key-需要唯一" aria-hidden="true">#</a> 4. 为什么 v-for 循环的 key 需要唯一？</h3><p>key 属性是 v-for 指令的参数，它用于指定当前元素的 key，key 必须是唯一的，这样 Vue 才能识别元素，从而高效地更新 DOM。</p><p>当使用 v-for 指令时，如果不提供 key 属性，可能会导致性能问题。key 属性用于确保 Vue.js 能够正确地更新 DOM，特别是当列表项的顺序发生变化时。key 属性应该是一个唯一的值，用于标识每个列表项。</p><h3 id="vue-中的生命周期是什么-当父子组件同事存在" tabindex="-1"><a class="header-anchor" href="#vue-中的生命周期是什么-当父子组件同事存在" aria-hidden="true">#</a> Vue 中的生命周期是什么(当父子组件同事存在)</h3><p>在父子组件之间，父组件的生命周期钩子函数总是在子组件的生命周期钩子函数之前被调用。例如，父组件的 beforeCreate 和 created 钩子函数会在子组件的相应钩子函数之前调用，而父组件的 mounted 钩子函数会在子组件的 mounted 钩子函数之后调用。</p><p>这种执行顺序确保了父组件可以在子组件挂载之前进行必要的准备工作，并在子组件挂载完成后对其进行操作。</p><h3 id="vue-组件如何通讯" tabindex="-1"><a class="header-anchor" href="#vue-组件如何通讯" aria-hidden="true">#</a> vue 组件如何通讯</h3><h3 id="描述组件渲染和更新的过程" tabindex="-1"><a class="header-anchor" href="#描述组件渲染和更新的过程" aria-hidden="true">#</a> 描述组件渲染和更新的过程</h3><h3 id="双向数据绑定-v-model-的实现原理" tabindex="-1"><a class="header-anchor" href="#双向数据绑定-v-model-的实现原理" aria-hidden="true">#</a> 双向数据绑定 v-model 的实现原理</h3>',21),c=[n];function s(v,f){return o(),t("div",null,c)}const u=e(h,[["render",s],["__file","interview09.html.vue"]]);export{u as default};
