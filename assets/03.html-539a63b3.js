import{_ as t,Z as e,a0 as p,F as c,a2 as o,a1 as l,X as i,Y as u,$ as r}from"./framework-5dd7fabc.js";const d={},k=e,n=p,m=c,v=o,g=l,a=r,h=i,b=u,f=a(`<p>虽然主题是手写 ajax，但是主要还是梳理一下前端流浪器发起数据请求的几种方法。</p><h2 id="fetch-函数" tabindex="-1"><a class="header-anchor" href="#fetch-函数" aria-hidden="true">#</a> fetch 函数</h2><p>当前主要流行的是使用浏览器提供的 fetch 函数，<code>fetch</code> 是浏览器提供的现代化的网络请求 API，它基于 Promise，支持异步操作。使用 <code>fetch</code> 函数可以发送 HTTP 请求并接收响应。</p><p>以下是使用 <code>fetch</code> 函数发送 GET 请求的示例：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">&#39;https://api.example.com/data&#39;</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> response<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 处理返回的数据</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 处理错误</span>
    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上述示例中，<code>fetch</code> 函数接收一个 URL 参数，并返回一个 Promise 对象。我们可以使用 <code>.then()</code> 方法来处理成功的响应，并使用 <code>.catch()</code> 方法来处理错误。</p><p><code>fetch</code> 函数返回的是一个代表响应的 <code>Response</code> 对象，我们可以使用 <code>.json()</code> 方法将响应的数据解析为 JSON 格式，或使用其他方法如 <code>.text()</code>、<code>.blob()</code> 等。</p><p><code>fetch</code> 函数还可以配置请求的方法、请求头、请求体等，以满足不同的需求。</p><h2 id="使用-xmlhttprequest-对象" tabindex="-1"><a class="header-anchor" href="#使用-xmlhttprequest-对象" aria-hidden="true">#</a> 使用 <code>XMLHttpRequest</code> 对象</h2><p><code>XMLHttpRequest</code> 是一个传统的方式，也是早期浏览器提供的发送 HTTP 请求的 API。它基于回调函数，较为复杂，但仍然被广泛使用。</p><p>ajax 即是对 XMLHttpRequest 进行封装的一种数据请求方法。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token function-variable function">ajax</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">url</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">&#39;GET&#39;</span><span class="token punctuation">,</span> url<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token comment">// get 方法请求, 支持异步操作</span>
    xhr<span class="token punctuation">.</span><span class="token function-variable function">onreadystatechange</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 当 readyState 属性发生变化时，调用的事件处理器。</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>readyState <span class="token operator">===</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 请求响应类型的枚举值</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>state <span class="token operator">===</span> <span class="token number">200</span> <span class="token operator">||</span> xhr<span class="token punctuation">.</span>state <span class="token operator">===</span> <span class="token number">304</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// 请求的响应状态</span>
          <span class="token function">resolve</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>responseText<span class="token punctuation">)</span> <span class="token comment">// 返回一个 DOMString，该 DOMString 包含对请求的响应，如果请求未成功或尚未发送，则返回 null。</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          <span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>responseText<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>方法共分为 5 步:</p><ol><li>定义 XMLHttpRequest</li><li>定义 open 方法发起请求</li><li>onreadystatechange 方法监听请求响应类型 readystate 和响应状态 state</li><li>依据请求状态返回数据</li><li>调用 send 方法发起实际请求</li></ol><h2 id="解释-jsonp-原理-为什么不是真正的-ajax" tabindex="-1"><a class="header-anchor" href="#解释-jsonp-原理-为什么不是真正的-ajax" aria-hidden="true">#</a> 解释 jsonp 原理，为什么不是真正的 ajax？</h2>`,15),x=a(`<p>其次要知道在 HTML 中，有几个标签和属性可以帮助绕过跨域限制，使得在页面上加载来自其他源的内容。</p><ol><li><p><code>&lt;img&gt;</code> 标签: 使用 <code>&lt;img&gt;</code> 标签可以加载来自其他域的图片资源。由于图片资源通常不受同源策略的限制，可以通过设置 <code>&lt;img&gt;</code> 标签的 <code>src</code> 属性来加载跨域的图片。</p><div class="language-html line-numbers-mode" data-ext="html"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>http://example.com/image.jpg<span class="token punctuation">&quot;</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Cross-origin image<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p><code>&lt;script&gt;</code> 标签的 <code>src</code> 属性: <code>&lt;script&gt;</code> 标签的 <code>src</code> 属性可以用来加载跨域的 JavaScript 文件。这可以用于实现 JSONP（JSON with Padding）技术。</p><div class="language-html line-numbers-mode" data-ext="html"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>http://example.com/script.js<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p><code>&lt;link&gt;</code> 标签的 <code>href</code> 属性: <code>&lt;link&gt;</code> 标签的 <code>href</code> 属性可以用来加载跨域的样式表文件（CSS）。</p><div class="language-html line-numbers-mode" data-ext="html"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>stylesheet<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>http://example.com/styles.css<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p><code>&lt;iframe&gt;</code> 标签: <code>&lt;iframe&gt;</code> 标签可以用来嵌入来自其他域的网页。通过设置 <code>src</code> 属性，可以加载跨域的网页内容。</p><div class="language-html line-numbers-mode" data-ext="html"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>iframe</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>http://example.com<span class="token punctuation">&quot;</span></span> <span class="token attr-name">frameborder</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>0<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>iframe</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p><code>sandbox</code> 属性: <code>&lt;iframe&gt;</code> 标签的 <code>sandbox</code> 属性可以用于创建一个受限制的沙盒环境，其中可以加载跨域的内容。通过 <code>sandbox</code> 属性，可以指定一些限制规则，例如禁止表单提交、脚本执行等。</p><div class="language-html line-numbers-mode" data-ext="html"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>iframe</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>http://example.com<span class="token punctuation">&quot;</span></span> <span class="token attr-name">sandbox</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>iframe</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ol><p>JSONP 实现跨域的原理就是通过动态创建 <code>&lt;script&gt;</code> 标签来加载外部脚本文件，这些脚本文件在服务器上生成并返回一个包装在函数调用中的 JSON 数据。</p><p>下面是 JSONP 的基本原理步骤：</p><ol><li><p>客户端（浏览器）创建一个 <code>&lt;script&gt;</code> 标签，并指定其 <code>src</code> 属性为跨域请求的 URL，同时将一个回调函数名作为查询参数传递给服务器。</p><div class="language-html line-numbers-mode" data-ext="html"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>http://example.com/api?callback=myCallback<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>服务器接收到请求后，根据回调函数名生成一个 JSON 数据的字符串，并将其包装在回调函数的调用中返回给客户端。服务器的响应内容类似于以下形式：</p><div class="language-json line-numbers-mode" data-ext="json"><pre class="language-json"><code>myCallback(<span class="token punctuation">{</span> name<span class="token operator">:</span> &#39;John&#39;<span class="token punctuation">,</span> age<span class="token operator">:</span> <span class="token number">25</span> <span class="token punctuation">}</span>)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>客户端在全局作用域中定义回调函数，以便在服务器返回的脚本被加载和执行时调用。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">myCallback</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>浏览器加载并执行服务器返回的脚本，触发回调函数调用，并将 JSON 数据作为参数传递给回调函数。</p></li></ol><p>JSONP 之所以不是真正的 AJAX（Asynchronous JavaScript and XML），是因为它并没有使用 XMLHttpRequest 对象来进行数据交互。相反，它使用了 <code>&lt;script&gt;</code> 标签来加载外部脚本文件，充分利用了浏览器对脚本文件的跨域访问没有同源策略限制的特性。</p><p>然而，JSONP 也存在一些限制和安全风险，例如它只能用于 GET 请求，无法处理 POST 请求。此外，由于 JSONP 的工作原理依赖于服务器返回的脚本内容，客户端需要完全信任服务器返回的脚本，以避免潜在的安全漏洞。因此，在使用 JSONP 时，需要确保从可信任的源加载脚本，并采取适当的安全措施来防止恶意脚本注入。</p>`,7);function q(_,j){const s=m("RouterLink");return h(),b("div",null,[f,k("p",null,[n("首先需要解释浏览器的同源策略(服务端没有同源策略)和跨域，具体可见 "),g(s,{to:"/OneMoreThing/Framework/webpack01.html"},{default:v(()=>[n("《解决前端跨域问题》")]),_:1}),n("。")]),x])}const S=t(d,[["render",q],["__file","03.html.vue"]]);export{S as default};
