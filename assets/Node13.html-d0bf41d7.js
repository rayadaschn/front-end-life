import{_ as o,Z as c,F as l,a1 as p,a0 as r,X as i,Y as d,$ as u}from"./framework-5dd7fabc.js";const k={},n=c,m=l,e=p,s=r,t=u,h=i,b=d,f=n("p",null,"此前简单梳理过一次大文件的分片上传，这里又重新实现一遍。功能点加上秒传、断点续传、web worker 等。",-1),v={href:"https://github.com/rayadaschn/fileUploader",target:"_blank",rel:"noopener noreferrer"},_=t('<h2 id="功能点总结" tabindex="-1"><a class="header-anchor" href="#功能点总结" aria-hidden="true">#</a> 功能点总结</h2><ol><li><p>前端分片上传与断点续传</p><ul><li>文件切片：用 <code>File.prototype.slice</code> 将大文件分割为多个小块（chunk），每块独立上传。</li><li>断点续传：上传前先向后端查询已上传分片，前端只上传未完成的分片，实现断点续传和秒传。</li><li>上传进度管理：每个分片上传时通过 onUploadProgress 事件实时更新进度条，整体进度通过所有分片进度的平均值计算。</li><li>取消与暂停：利用 <code>axios</code> 的 <code>CancelToken</code> 实现上传任务的取消和暂停，支持恢复上传。</li></ul></li><li><p>Web Worker 计算文件 hash `- Web Worker 基础：用 Worker 在浏览器主线程外异步计算大文件 hash，避免 UI 卡顿。</p><ul><li>主线程与 Worker 通信：通过 <code>postMessage</code> 和 <code>onmessage</code> 实现主线程与 Worker 的数据交互。</li><li>SubtleCrypto API：在 Worker 内用 <code>crypto.subtle.digest</code> 计算文件内容的 SHA-256 hash，生成唯一文件名。</li></ul></li><li><p>React 组件与自定义 Hook</p><ul><li>自定义 Hook：用 <code>useDrag</code> 实现拖拽上传、点击上传、文件校验、预览等功能，提升组件复用性。</li><li><code>useRef</code>/<code>useState</code>/<code>useEffect</code>：管理 DOM 引用、状态和副作用，确保事件监听和资源释放的正确性。</li></ul></li><li><p>Node.js 服务端分片处理</p><ul><li>Express 路由设计：实现 <code>/api/upload</code>（分片上传）、<code>/api/check</code>（查询已上传分片）、<code>/api/merge</code>（合并分片）等接口。</li><li>流式处理：用 <code>fs.createReadStream</code> 和 <code>fs.createWriteStream</code> 实现分片的高效写入和合并，避免大文件占用过多内存。</li><li>慢速 Transform 流：自定义 <code>SlowTransform</code>，通过 <code>setTimeout</code> 控制写入速度，方便前端调试进度条和断点续传。</li><li>分片合并与 hash 校验：合并所有分片后，流式计算合并文件的 hash，与前端生成的 hash 比较，确保文件完整性。</li></ul></li><li><p>性能优化</p><ul><li>并行上传与合并：前端并行上传多个分片，后端可并行或串行合并，提升效率。</li><li>内存优化：所有大文件操作均采用流式处理，避免内存溢出。</li><li>兼容性与用户体验：支持拖拽、点击、进度反馈、错误提示、断点续传等，提升易用性。</li></ul></li></ol><h2 id="基础知识点总结" tabindex="-1"><a class="header-anchor" href="#基础知识点总结" aria-hidden="true">#</a> 基础知识点总结</h2>',3),y=t(`<li><p>Blob、ArrayBuffer 和 Uint8Array 的区别</p><table><thead><tr><th>名称</th><th>类比</th><th>作用</th></tr></thead><tbody><tr><td><code>ArrayBuffer</code></td><td>一块内存（生数据）</td><td>原始二进制数据，不能直接访问</td></tr><tr><td><code>Uint8Array</code></td><td>眼镜/视图</td><td>用来访问 <code>ArrayBuffer</code> 中的内容</td></tr><tr><td><code>Blob</code></td><td>文件/盒子</td><td>表示一段数据，可以是字符串、二进制、文件等，不提供直接访问方式</td></tr></tbody></table><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 1. 创建一个 Uint8Array（8 位二进制数组）</span>
<span class="token keyword">const</span> uint8 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Uint8Array</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token comment">// 2. 把它打包成 Blob（像是准备上传的文件）</span>
<span class="token keyword">const</span> blob <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Blob</span><span class="token punctuation">(</span><span class="token punctuation">[</span>uint8<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">&#39;application/octet-stream&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 3. 异步把 Blob 转回 ArrayBuffer（像是打开文件）</span>
blob<span class="token punctuation">.</span><span class="token function">arrayBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">buf</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 4. 用视图读取 buffer 内容</span>
  <span class="token keyword">const</span> view <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Uint8Array</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>view<span class="token punctuation">)</span> <span class="token comment">// Uint8Array(3) [1, 2, 3]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>`,1),w=n("p",null,"关于 web worker",-1),g={href:"https://javascript.ruanyifeng.com/htmlapi/webworker.html",target:"_blank",rel:"noopener noreferrer"},B=n("p",null,"这里需要说明的是，使用 web worker 并不能提高性能，因为它仍然是单线程的。它的主要作用是将耗时的计算任务从主线程中分离出来，避免阻塞 UI 渲染。",-1);function x(A,N){const a=m("ExternalLinkIcon");return h(),b("div",null,[f,n("p",null,[s("前端简单用 vite + react19 + antd + axios 实现。后端用 express 实现。"),n("a",v,[s("代码仓库"),e(a)])]),_,n("ol",null,[y,n("li",null,[w,n("p",null,[s("简单入门可以看阮一峰老师总结: "),n("a",g,[s("web worker"),e(a)])]),B])])])}const W=o(k,[["render",x],["__file","Node13.html.vue"]]);export{W as default};
