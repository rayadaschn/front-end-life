import{_ as e,X as i,Y as l,$ as a}from"./framework-97fa2d96.js";const o={},t=a,n=i,d=l,s=t(`<p>框架类面试主要考察三个方面:</p><ul><li>框架的使用(基本使用, 高级特性, 周边插件)</li><li>框架的原理(基本原理的了解, 热门技术的深度和全面性)</li><li>框架的实际应用,即设计能力(组件结构和数据结构)</li></ul><h2 id="基本使用" tabindex="-1"><a class="header-anchor" href="#基本使用" aria-hidden="true">#</a> 基本使用</h2><ul><li>指令和插值 <ul><li>插值、表达式</li><li>指令、动态属性</li><li>v-html：会有 XSS 风险，会覆盖子组件</li></ul></li><li>computed 和 watch <ul><li>computed 有缓存 data 不变则不会重新计算</li><li>watch 的深度监听</li><li>watch 监听引用类型，拿不到 oldValue</li></ul></li><li>class 和 style</li><li>条件渲染 <ul><li><code>v-if</code> 和 <code>v-else</code> 的用法, 可使用变量, 也可使用 <code>===</code> 表达式</li><li><code>v-if</code> 和 <code>v-show</code> 的区别</li><li><code>v-if</code> 和 <code>v-show</code> 的使用场景</li></ul></li><li>循环(列表)渲染 <ul><li>如何遍历对象? -- <code>v-for</code></li><li>key 的重要性，key 不能重复</li><li><code>v-for</code> 和 <code>v-if</code> 不能一起使用</li></ul></li><li>事件 <ul><li>event 参数，自定义参数</li><li>事件修饰符 <ul><li>阻止单击事件继续传播: <code>&lt;a @click.stop=&quot;doThis&quot; &gt;A&lt;/a&gt;</code></li><li>提交时间不再重载页面: <code>&lt;a @click.submit.prevent=&quot;onSubmit&quot; &gt;B&lt;/a&gt;</code></li><li>修饰符可以串联: <code>&lt;a @click.stop.prevent=&quot;doThat&quot; &gt;C&lt;/a&gt;</code></li><li>只有修饰符: <code>&lt;a v-on:submit.prevent=&quot;doThat&quot; &gt;D&lt;/a&gt;</code></li></ul></li><li>按键修饰符 <ul><li>即使 Alt 或 Shift 被一同按下也会触发: <code>&lt;a @click.ctrl=&quot;onClick&quot; &gt;A&lt;/a&gt;</code></li><li>只有 Ctrl 被按下才会触发: <code>&lt;a @click.ctrl.exact=&quot;onClick&quot; &gt;B&lt;/a&gt;</code></li><li>没有任何修饰符被按下时才会触发: <code>&lt;a @click.exact=&quot;onClick&quot; &gt;C&lt;/a&gt;</code></li></ul></li><li>事件如何绑定 -- <code>@click</code></li></ul></li><li>表单 <ul><li>v-model</li><li>常见表单项 textarea,checkbox,radio,select</li><li>修饰符 v-model.lazy, v-model.number, v-model.trim</li></ul></li></ul><h2 id="vue-组件使用" tabindex="-1"><a class="header-anchor" href="#vue-组件使用" aria-hidden="true">#</a> vue 组件使用</h2><ul><li>组件间通信 : props 和 $emit</li><li>自定义事件</li><li>生命周期 <ul><li>单个: 挂载,更新,销毁</li><li>多个(父子组件): <ul><li>created(setup): 父 -&gt; 子</li><li>mounted(onMounted): 子 -&gt; 父</li><li>beforeUpdate(onBeforeUpdate): 父 -&gt; 子</li><li>updated(onUpdated): 子 -&gt; 父</li><li>beforeDestroy(onBeforeUnmount): 父 -&gt; 子</li><li>destroyed(onUnmounted): 子 -&gt; 父</li></ul></li></ul></li><li>props(类型和默认值)</li><li>v-on</li></ul><h2 id="vue-的高级特性" tabindex="-1"><a class="header-anchor" href="#vue-的高级特性" aria-hidden="true">#</a> vue 的高级特性</h2><ul><li><p>自定义 v-model</p></li><li><p>$nextTick</p><ul><li>Vue 是异步渲染;</li><li>data 改变之后, DOM 不会立即渲染;</li><li>$nextTick 会在 DOM 渲染之后执行，以获取最新的 DOM 节点。</li></ul></li><li><p>slot 插槽: 父组件向子组件传递内容</p><ul><li>作用域插槽 <code>v-slot=&quot;{ item }&quot;</code> : 父组件向子组件传递内容</li><li>具名插槽 <code>v-slot:xxx</code>: 父组件向子组件传递内容，并指定插槽的名字</li></ul></li><li><p>keep-alive</p><ul><li>场景: 缓存组件;频繁切换,不需要重复渲染的组件;vue 性能优化。</li><li>同 <code>v-show</code> 的区别: <code>keep-alive</code> 是在 vue 框架层级进行的 JS 对象渲染; <code>v-show</code>是 CSS display 控制显示和隐藏</li></ul></li><li><p>mixin: 多个组件有相同逻辑,抽离出来。vue3 中已被 composition API 所代替。</p></li><li><p>动态、异步组件</p><ul><li><p>动态组件: <code>&lt;component :is=&#39;componentName&#39;&gt;</code></p></li><li><p>异步组件: - 考点: <code>import()</code>函数和按需异步加载</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> defineAsyncComponent <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span>
<span class="token comment">// simple usage</span>
<span class="token keyword">const</span> LoginPopup <span class="token operator">=</span> <span class="token function">defineAsyncComponent</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
  <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">&#39;./components/LoginPopup.vue&#39;</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li></ul><h2 id="全局数据管理-vuex" tabindex="-1"><a class="header-anchor" href="#全局数据管理-vuex" aria-hidden="true">#</a> 全局数据管理 vuex</h2><p>Vue3 中已被 pinia 所代替。</p><figure><img src="https://vuex.vuejs.org/vuex.png" alt="vuex" tabindex="0" loading="lazy"><figcaption>vuex</figcaption></figure><ul><li>state</li><li>getters</li><li>action</li><li>mutation</li><li>在 vue 中使用: <ul><li>dispatch</li><li>commit</li><li>mapState</li><li>mapGetters</li><li>mapActions</li><li>mapMutations</li></ul></li></ul><h2 id="vue-router" tabindex="-1"><a class="header-anchor" href="#vue-router" aria-hidden="true">#</a> vue-router</h2><ul><li>路由模式(hash、H5 history)</li><li>路由配置（动态路由、懒加载）</li><li>路由守卫（全局守卫、路由独享守卫、组件内守卫）</li><li>路由组件传参（query、params）</li></ul><h2 id="框架原理" tabindex="-1"><a class="header-anchor" href="#框架原理" aria-hidden="true">#</a> 框架原理</h2><h3 id="_1-什么是虚拟-dom" tabindex="-1"><a class="header-anchor" href="#_1-什么是虚拟-dom" aria-hidden="true">#</a> 1. 什么是虚拟 DOM？</h3><p>虚拟 DOM（Virtual DOM）是一种模拟真实 DOM 的技术，它把浏览器页面渲染时需要进行的 DOM 操作模拟成 JavaScript 对象，这样就可以在运行时更高效地更新 DOM。虚拟 DOM 的优点是可以在较短的时间内虚拟地表示真实 DOM，并且可以方便地实现跨平台和跨浏览器。</p><h3 id="_2-v-show-和-v-if-有什么区别" tabindex="-1"><a class="header-anchor" href="#_2-v-show-和-v-if-有什么区别" aria-hidden="true">#</a> 2. v-show 和 v-if 有什么区别？</h3><p>v-show 指令是通过设置元素的 display 属性来控制元素是否显示，而 v-if 指令是通过控制元素在文档中的存在性来控制元素的显示和隐藏。</p><p>v-show 指令在初始渲染时就会创建元素，而 v-if 指令在条件第一次满足时才会创建元素，在条件第二次满足时会销毁元素，因此 v-if 指令比 v-show 指令具有更高的性能。</p><p>v-show 指令在条件改变时，并不会去操作 DOM，而 v-if 指令在条件改变时，会根据条件的改变去操作 DOM。</p><h3 id="_3-v-for-和-v-if-一起使用有什么问题" tabindex="-1"><a class="header-anchor" href="#_3-v-for-和-v-if-一起使用有什么问题" aria-hidden="true">#</a> 3. v-for 和 v-if 一起使用有什么问题？</h3><p>v-for 指令和 v-if 指令不能同时使用，因为 v-for 指令会遍历数组或对象，而 v-if 指令会从初始渲染时就创建元素，因此 v-for 指令和 v-if 指令不能同时使用。</p><h3 id="_4-为什么-v-for-循环的-key-需要唯一" tabindex="-1"><a class="header-anchor" href="#_4-为什么-v-for-循环的-key-需要唯一" aria-hidden="true">#</a> 4. 为什么 v-for 循环的 key 需要唯一？</h3><p>key 属性是 v-for 指令的参数，它用于指定当前元素的 key，key 必须是唯一的，这样 Vue 才能识别元素，从而高效地更新 DOM。</p><p>当使用 v-for 指令时，如果不提供 key 属性，可能会导致性能问题。key 属性用于确保 Vue.js 能够正确地更新 DOM，特别是当列表项的顺序发生变化时。key 属性应该是一个唯一的值，用于标识每个列表项。</p><h3 id="vue-中的生命周期是什么-当父子组件同事存在" tabindex="-1"><a class="header-anchor" href="#vue-中的生命周期是什么-当父子组件同事存在" aria-hidden="true">#</a> Vue 中的生命周期是什么(当父子组件同事存在)</h3><p>在父子组件之间，父组件的生命周期钩子函数总是在子组件的生命周期钩子函数之前被调用。例如，父组件的 beforeCreate 和 created 钩子函数会在子组件的相应钩子函数之前调用，而父组件的 mounted 钩子函数会在子组件的 mounted 钩子函数之后调用。</p><p>这种执行顺序确保了父组件可以在子组件挂载之前进行必要的准备工作，并在子组件挂载完成后对其进行操作。</p><h3 id="vue-组件如何通讯" tabindex="-1"><a class="header-anchor" href="#vue-组件如何通讯" aria-hidden="true">#</a> vue 组件如何通讯</h3><h3 id="描述组件渲染和更新的过程" tabindex="-1"><a class="header-anchor" href="#描述组件渲染和更新的过程" aria-hidden="true">#</a> 描述组件渲染和更新的过程</h3><h3 id="双向数据绑定-v-model-的实现原理" tabindex="-1"><a class="header-anchor" href="#双向数据绑定-v-model-的实现原理" aria-hidden="true">#</a> 双向数据绑定 v-model 的实现原理</h3>`,32),c=[s];function r(u,p){return n(),d("div",null,c)}const v=e(o,[["render",r],["__file","interview09.html.vue"]]);export{v as default};
