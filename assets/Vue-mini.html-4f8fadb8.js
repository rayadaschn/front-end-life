import{_ as n,X as s,Y as a,$ as e}from"./framework-97fa2d96.js";const t={},p=e,o=s,c=a,l=p(`<blockquote><p>尤雨溪：框架的设计过程其实是一个不断取舍的过程。</p></blockquote><h2 id="理解命令式和声明式" tabindex="-1"><a class="header-anchor" href="#理解命令式和声明式" aria-hidden="true">#</a> 理解命令式和声明式</h2><p>&quot;命令式&quot;（Imperative）和&quot;声明式&quot;（Declarative）是两种编程范式，用来描述编程语言或编程风格的不同方式。</p><ol><li><p><strong>命令式（Imperative）</strong>：</p><ul><li><strong>关注步骤和过程：</strong> 命令式编程关注如何完成一个任务，通过指定每个步骤来达到目标。</li><li><strong>具体的控制流：</strong> 开发者需要详细说明程序的控制流程，包括循环、条件语句等。</li><li><strong>修改状态：</strong> 程序通过改变状态来实现目标，通常使用变量来存储和修改状态。</li><li><strong>示例：</strong> 常见的命令式编程语言包括 C、C++、Java。例如，下面是一个简单的命令式编程的示例，计算阶乘的函数：</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 计算阶乘的命令式函数</span>

  <span class="token keyword">function</span> <span class="token function">factorial</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  result \\<span class="token operator">*=</span> i<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> result<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">factorial</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出: 120</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>声明式（Declarative）</strong>：</p><ul><li><p><strong>关注结果而非步骤：</strong> 声明式编程关注定义要达到的目标，而不是详细说明如何实现这个目标。</p></li><li><p><strong>抽象控制流：</strong> 具体的控制流程由编程语言或框架隐式处理，而不需要开发者明确指定。</p></li><li><p><strong>不修改状态：</strong> 避免直接修改状态，而是通过声明式的方式描述所需的状态。</p></li><li><p><strong>示例：</strong> 常见的声明式编程语言包括 SQL、HTML、React 中的 JSX。以下是一个声明式的 React 组件示例：</p><div class="language-jsx line-numbers-mode" data-ext="jsx"><pre class="language-jsx"><code><span class="token keyword">function</span> <span class="token function">Greeting</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> name <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Hello, </span><span class="token punctuation">{</span>name<span class="token punctuation">}</span><span class="token plain-text">!</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li></ol><p>总的来说，声明式代码更利于阅读，也更利于维护，但是性能弱于命令式（步骤更多）。</p><h2 id="区分运行时和编译时" tabindex="-1"><a class="header-anchor" href="#区分运行时和编译时" aria-hidden="true">#</a> 区分运行时和编译时</h2><p>Vue 是一个运行时 ➕ 编译时的框架。</p><p>通过 compiler 解析 html 模版，生成 render 函数，再通过 runtime 解析 render，从而挂载真实 DOM。</p><h2 id="理解-proxy-和-reflect" tabindex="-1"><a class="header-anchor" href="#理解-proxy-和-reflect" aria-hidden="true">#</a> 理解 Proxy 和 Reflect</h2><p><code>Proxy</code> 和 <code>Reflect</code> 是 JavaScript 中的两个关键对象，它们分别用于操作和拦截对象的操作。</p><h3 id="proxy-代理" tabindex="-1"><a class="header-anchor" href="#proxy-代理" aria-hidden="true">#</a> Proxy（代理）</h3><p><code>Proxy</code> 对象用于创建一个对象的代理，可以拦截并重定义该对象上的基本操作。它的基本语法如下：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">let</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> handler<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><code>target</code>: 要代理的目标对象。</li><li><code>handler</code>: 一个对象，其属性是用于定制代理行为的函数。</li></ul><p>代理对象将所有操作转发到目标对象，并且你可以在 <code>handler</code> 中定义附加的行为。例如，可以在代理对象上设置 <code>get</code> 方法来拦截对目标对象属性的访问：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">let</span> target <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&#39;John&#39;</span> <span class="token punctuation">}</span>

<span class="token keyword">let</span> handler <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> receiver</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">Getting property &quot;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>prop<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&quot;</span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> target<span class="token punctuation">[</span>prop<span class="token punctuation">]</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> handler<span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>proxy<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment">// 输出: Getting property &quot;name&quot;，然后输出 &quot;John&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的例子中，当访问 <code>proxy.name</code> 时，<code>get</code> 方法被触发，输出相应的信息并返回目标对象的属性值。</p><h3 id="reflect-反射" tabindex="-1"><a class="header-anchor" href="#reflect-反射" aria-hidden="true">#</a> Reflect（反射）</h3><p><code>Reflect</code> 对象提供了一组用于访问对象的方法，这些方法与操作符对应。<code>Reflect</code> 方法和对应的操作符有着一一对应的关系，例如 <code>Reflect.get()</code> 对应于 <code>obj[prop]</code>。</p><p><code>Reflect</code> 的目的是为了替代一些以前可能直接在对象上执行的操作，使其更加规范和易于理解。例如，<code>Reflect.get()</code> 等价于 <code>obj[prop]</code>，但是它是一个函数，可以更容易地在函数式编程中使用。在 Vue 中则是配合 Proxy 改变 this 指向，下文 👇🏻 会介绍到。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">let</span> target <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&#39;John&#39;</span> <span class="token punctuation">}</span>

<span class="token comment">// 使用 Reflect.get() 获取属性值</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> <span class="token string">&#39;name&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 输出: John</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>Reflect</code> 还有其他一些方法，例如 <code>Reflect.set()</code>，<code>Reflect.has()</code>，等等，它们分别对应了对象属性的设置、检查属性是否存在等操作。</p><p>总体而言，<code>Proxy</code> 和 <code>Reflect</code> 结合使用可以提供更灵活和强大的对象操作机制。<code>Proxy</code> 用于拦截和定制对象的行为，而 <code>Reflect</code> 提供了一组规范的方法来执行常见的对象操作。</p><h3 id="为什么它们可以组合使用" tabindex="-1"><a class="header-anchor" href="#为什么它们可以组合使用" aria-hidden="true">#</a> 为什么它们可以组合使用?</h3><p>当我们期望监听代理对象的 getter 和 setter 方法时，不应该使用 <code>target[key]</code>，因为它在某些时候是不可靠的，而应该借助 Reflect 的 get 和 set 方法，使用 receiver（proxy 实例）作为 this，以达到期望的结果。</p><p>如：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">firstName</span><span class="token operator">:</span> <span class="token string">&#39;Huy&#39;</span><span class="token punctuation">,</span>
  <span class="token literal-property property">lastName</span><span class="token operator">:</span> <span class="token string">&#39;John&#39;</span><span class="token punctuation">,</span>
  <span class="token keyword">get</span> <span class="token function">fullName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lastName <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>firstName
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;触发 getter 方法&#39;</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> target<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>proxy<span class="token punctuation">.</span>fullName<span class="token punctuation">)</span> <span class="token comment">// JohnHuy</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面例子中，proxy 的 get 方法实际触发了 1 次。这其实“有点反常识”的。来看一下，每当 proxy 获取它的属性时，就会调用这个 get 方法。</p><p>按照预想：</p><ol><li>获取 fullName 时，调用一次 proxy 的 get；</li><li>在 fullName 中又使用 this 去调用 obj 的方法时还应当再调用 proxy 的 get 方法。</li></ol><p>原因在于 fullName 中的 this 指向 obj 对象本身，而不是 proxy。因此需要用到 Reflect 反射来改变其中的 this 指向。</p><p>因此利用 Proxy 和 Reflect 共有的第三个属性 receiver 进行改造：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">firstName</span><span class="token operator">:</span> <span class="token string">&#39;Huy&#39;</span><span class="token punctuation">,</span>
  <span class="token literal-property property">lastName</span><span class="token operator">:</span> <span class="token string">&#39;John&#39;</span><span class="token punctuation">,</span>
  <span class="token keyword">get</span> <span class="token function">fullName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lastName <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>firstName
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;触发 getter 方法&#39;</span><span class="token punctuation">)</span> <span class="token comment">// 成功打印 3 次</span>
    <span class="token comment">// return target[key]</span>
    <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token comment">// 利用 Reflect 改变 this 指向</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>proxy<span class="token punctuation">.</span>fullName<span class="token punctuation">)</span> <span class="token comment">// JohnHuy</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,33),i=[l];function u(r,d){return o(),c("div",null,i)}const v=n(t,[["render",u],["__file","Vue-mini.html.vue"]]);export{v as default};
