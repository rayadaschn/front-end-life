import{_ as c,Z as l,a0 as t,F as i,a1 as d,X as r,Y as p,$ as u}from"./framework-97fa2d96.js";const k={},o=l,e=t,m=i,n=d,a=u,g=r,b=p,v=a('<h1 id="docker-速通" tabindex="-1"><a class="header-anchor" href="#docker-速通" aria-hidden="true">#</a> Docker 速通</h1><p><strong>Docker</strong> 是什么?</p><p>没看懂的官网简介：“Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app），更重要的是容器性能开销极低。”</p><p><strong>通俗理解：Docker 可以通过将应用程序和相关依赖项封装到容器中，实现在不同环境下运行相同的应用程序。这使得开发人员可以在本地创建和测试应用程序，并将其打包成 Docker 镜像并将其部署到测试、预发布和生产环境中。</strong> 就像是乐高积木一样，我需要什么功能，就用什么模块，不再需要为了某一个功能重开一个虚拟机，配置独立的运行环境。</p><blockquote><p>“将应用程序和相关依赖项封装到容器中” 的意思是：</p><p>将依赖项封装到容器中是指将应用程序所需要的所有依赖项（如软件包、库、配置文件等）打包成一个独立的容器镜像。这个镜像中包含了应用程序所需的所有环境配置和代码，可以在任何支持 Docker 的环境中运行，从而确保应用程序在不同的机器或者环境下有一致的运行表现。因此，将依赖项封装到容器中，可以避免各种环境之间的差异性所带来的问题，例如不同操作系统、不同版本的软件库等，极大地提高了应用程序的可移植性和部署效率。</p></blockquote><h2 id="前置知识" tabindex="-1"><a class="header-anchor" href="#前置知识" aria-hidden="true">#</a> 前置知识</h2>',6),h=o("strong",null,"systemctl",-1),D={href:"https://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html",target:"_blank",rel:"noopener noreferrer"},f=o("strong",null,"ctl 的意思是 control，也就是控制",-1),x=a(`<p>Docker 中镜像和容器是两个不同的概念。</p><p>镜像（Image）是一个只读的模板，它包含了用于创建 Docker 容器的文件系统和参数。镜像可以看作是一个软件的打包文件，它包含了完整的文件系统和软件运行所需的依赖，可以用来创建多个相同的容器实例。镜像可以通过 Docker 的构建工具 Dockerfile 或者从 Docker Hub 上下载获得。</p><p>容器（Container）是一个可运行的实例，它是从镜像创建的一个可写的分层文件系统。容器可以看作是一个独立的、轻量级的、可移植的运行环境，可以在其中运行应用程序。容器可以被启动、停止、删除，并且可以与其他容器和主机进行通信。</p><p>简单来说，镜像是应用程序的静态打包，而容器是应用程序的动态运行。在创建容器时，Docker 会根据镜像创建一个可执行的运行环境，其中包括文件系统、网络等资源，然后在该运行环境中启动应用程序。</p><p>在 Docker 中，可以通过使用<strong>相同/不同</strong>的镜像来创建<strong>多个容器实例</strong>，每个容器实例都是相互独立的。这使得 Docker 容器可以实现极高的可移植性和容器化部署。</p><h2 id="安装及常用命令" tabindex="-1"><a class="header-anchor" href="#安装及常用命令" aria-hidden="true">#</a> 安装及常用命令</h2><p>值得注意的是，Docker 并非是一个通用的容器工具，它依赖于已存在并运行的 Linux 内核环境。因此，Docker 必须部署在 Linux 内核的系统上。</p><p>本地开发端 Mac 安装：</p><ul><li>推荐使用 Brew，简化安装过程、升级版本便利，还能确保环境的干净和可重复性。</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$: brew <span class="token function">install</span> <span class="token function">docker</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,10),_=o("code",null,"arm64",-1),q={href:"https://desktop.docker.com/mac/main/arm64/Docker.dmg",target:"_blank",rel:"noopener noreferrer"},I=a(`<p>服务器端 CentOS 安装：</p><ol><li>安装： <code>yum -y install docker-ce docker-ce-cli containerd.io</code></li><li>启动 Docker： <code>systemctl start docker</code></li><li>测试：<code>docker version</code></li><li>卸载： <ul><li><code>systemctl stop docker</code></li><li><code>yum remove docker-ce docker-ce-cli containerd.io</code></li><li><code>rm -rf /var/lib/docker</code></li><li><code>rm -rf /var/lib/containerd</code></li></ul></li></ol><p>容器常用指令：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 查看所有帮助文件</span>
$: <span class="token function">docker</span> <span class="token parameter variable">--help</span>

<span class="token comment"># 查看某一指令的帮助文件</span>
$: <span class="token function">docker</span> <span class="token operator">&lt;</span>OPTIONS<span class="token operator">&gt;</span> <span class="token parameter variable">--help</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>总体步骤：</p><ol><li>搜索镜像：<strong>docker search tomcat</strong></li><li>拉取镜像</li><li>查看镜像</li><li>启动镜像</li><li>停止镜像</li><li>移除容器</li></ol><p>有镜像才能创建容器，下载镜像相当于下拉包：</p><ul><li>下载 CentOS：<code>docker pull centos</code></li><li>下载 Ubuntu：<code>docker pull ubuntu</code></li></ul><ol><li><p>新建并启动容器：<code>docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</code></p><ul><li><p>OPTIONS 说明 有些是一个 <strong>“<code>-</code>”<strong>有些是俩个</strong>“<code>--</code>”</strong>；</p></li><li><p><code>--name</code> 容器新名字，为容器指定一个名称；</p></li><li><p><code>-d</code>：后台运行容器 ID，即启动后台守护式容器；</p></li><li><p><code>-i</code>：表示将标准输入 (stdin) 绑定到容器的交互式 shell。这个选项可以让你将本地计算机上的文件传递给容器，或者从容器中提取文件到本地计算机。，通常与“<code>-t</code>” 同时使用；</p></li><li><p><code>-t</code>：在创建容器时为其分配一个伪终端 (pseudo-tty)，生成可交互的 shell 环境。这个选项可以让你在容器内部执行命令，并且可以像在本地终端一样与容器交互。通常与“<code>-i</code>”同时使用；</p></li><li><p><code>-P</code>：大写 P 为随即端口映射；</p></li><li><p><code>-p</code>：小写 p 为指定端口。</p></li></ul><blockquote><p><code>-it</code> 与 <code>-d</code> 的区别：</p><p><code>docker run -it ubuntu bash</code> ： 前台命令行交互；</p><p><code>docker run -d nginx</code>：容器后台运行。</p></blockquote></li><li><p>列出当前所有正在运行的容器：<code>docker ps [OPTIONS]</code></p><ul><li><code>-a</code>：列出当前所有正在运行的容器 + 历史上运行过的；</li><li><code>-l</code>：显示最近创建的容器；</li><li><code>-n</code>：显示最近 n 个创建的容器；</li><li><code>-q</code>：静默模式，只显示编号。</li></ul></li><li><p>退出容器：</p><ul><li>exit：run 进去容器，exit 退出，容器停止；</li><li>ctrl + p + q：run 进去容器， ctrl + p + q 退出，容器不停止。</li></ul></li><li><p>启动已经停止运行的容器：<code>docker start &lt;容器 ID 或容器名&gt;</code></p></li><li><p>重启容器：<code>docker restart &lt;容器 ID 或容器名&gt;</code></p></li><li><p>停止容器：<code>docker stop &lt;容器 ID 或容器名&gt;</code></p></li><li><p>强制停止容器：<code>docker kill &lt;容器 ID 或容器名&gt;</code></p><blockquote><p>stop 优于 kill</p><p>容器会收到信号后尝试执行一些清理工作，如保存数据、关闭连接等，然后自行退出。如果容器在一定时间内（默认为 10 秒）没有正常退出，Docker 会发送 <code>SIGKILL</code> 信号强制终止容器。</p></blockquote></li><li><p>删除已停止的容器：<code>docker rm &lt;容器 ID&gt;</code></p></li><li><p>删除本地的 Docker 镜像，可以删除一个或多个镜像: <code>docker rmi &lt;镜象 ID&gt;</code></p></li><li><p>查看容器日志：<code>docker logs &lt;容器 ID&gt;</code></p></li><li><p>查看容器内运行的进程：<code>docker top &lt;容器 ID&gt;</code></p></li><li><p>查看容器内部细节：<code>docker inspect &lt;容器 ID&gt;</code></p></li><li><p>进入正在运行的容器并以命令行交互：<code>docker exec -it &lt;容器 ID&gt; bashShell</code></p></li><li><p>从容器内部拷贝文件到主机上：<code>docker cp &lt;容器 ID&gt; &lt;目的主机路径&gt;</code></p></li><li><p>导入容器：<code>cat &lt;文件名.文件后缀&gt; | docker import - &lt;镜像用户/镜像名:镜像版本号&gt;</code></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$: <span class="token function">cat</span> README.md <span class="token operator">|</span> <span class="token function">docker</span> <span class="token function">import</span> - huy/ubuntu:2.0
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>导出容器：<code>docker export &lt;容器 ID&gt; &gt; &lt;文件名.文件后缀&gt;</code></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$: <span class="token function">docker</span> <span class="token builtin class-name">export</span> <span class="token number">123456</span> <span class="token operator">&gt;</span> README.md
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>容器卷同宿主机连接：<code>docker run -it --privileged=true -v &lt;/宿主机绝对路径目录:/容器目录&gt; &lt;镜像名或 ID&gt;:&lt;版本号&gt;</code></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$: <span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--privileged</span><span class="token operator">=</span>true <span class="token parameter variable">-v</span> /mydocker/u:/tmp ubuntu
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>-v</code> 是 volume 卷。</p><blockquote><p>容器之间的配置信息的传递，数据卷容器的生命周期会一直持续到没有容器使用为止，一旦持久化到了本地，则这个本地的数据是不会删除的。</p></blockquote></li><li><p>从容器中拷贝文件：</p></li></ol><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$: <span class="token function">docker</span> <span class="token function">cp</span> <span class="token operator">&lt;</span>容器 ID<span class="token operator">&gt;</span>:<span class="token operator">&lt;</span>目录<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>宿主机目标目录<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote><p>export 和 cp 的区别：</p><p><code>docker export</code> 和 <code>docker cp</code> 都是 Docker 命令，但它们的功能和使用场景是不同的。</p><p><code>docker export</code> 命令用于将 Docker 容器的文件系统打包成一个 tar 归档文件并导出，可以用于备份、迁移、共享镜像等。但是，导出的文件不包含容器的元数据信息，比如容器的名称、标签、网络配置等，也不包含容器的历史记录。因此，使用 <code>docker export</code> 命令导出的文件不能直接用于创建 Docker 镜像或容器。示例命令如下：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$: <span class="token function">docker</span> <span class="token builtin class-name">export</span> <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span> CONTAINER_ID <span class="token operator">&gt;</span> archive.tar
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>docker cp</code> 命令用于在 Docker 容器和主机之间复制文件或目录。可以从容器中复制文件到主机，也可以将主机中的文件复制到容器中。示例命令如下：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$: <span class="token function">docker</span> <span class="token function">cp</span> <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span> CONTAINER_ID:SRC_PATH DEST_PATH
$: <span class="token function">docker</span> <span class="token function">cp</span> <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span> SRC_PATH CONTAINER_ID:DEST_PATH
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>需要注意的是，<code>docker cp</code> 命令只能用于正在运行的 Docker 容器，而不是已经停止的容器或镜像。另外，<code>docker cp</code> 命令可以使用 <code>-r</code> 选项来递归复制整个目录。</p></blockquote><h2 id="自定义发布镜像" tabindex="-1"><a class="header-anchor" href="#自定义发布镜像" aria-hidden="true">#</a> 自定义发布镜像</h2><p>commit 自制镜像</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$: <span class="token function">docker</span> commit <span class="token parameter variable">-m</span><span class="token operator">=</span><span class="token string">&quot;提交的信息&quot;</span> <span class="token parameter variable">-a</span><span class="token operator">=</span><span class="token string">&quot;作者&quot;</span> <span class="token operator">&lt;</span>容器 id<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>目标镜像名<span class="token operator">&gt;</span>:<span class="token operator">&lt;</span>TAG<span class="token operator">&gt;</span>

$: <span class="token function">docker</span> commit <span class="token parameter variable">-m</span><span class="token operator">=</span><span class="token string">&quot;新增的一个自定义镜像&quot;</span> <span class="token parameter variable">-a</span><span class="token operator">=</span><span class="token string">&quot;Huy&quot;</span> 123xxxabc ubuntu_huy:1.0
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>docker push 发布镜像。</p><h3 id="dockerfile" tabindex="-1"><a class="header-anchor" href="#dockerfile" aria-hidden="true">#</a> DockerFile</h3><p>Dockerfile 是用于构建 Docker 镜像的文本文件。它包含一组指令，这些指令描述了如何构建 Docker 镜像，包括从哪里获取基础镜像、如何安装软件包、如何设置环境变量、如何暴露端口等等。</p><p>简单的 Dockerfile 示例（注意这是一个纯文本文件，通常直接命名为“Dockerfile”）：</p><div class="language-Dockerfile line-numbers-mode" data-ext="Dockerfile"><pre class="language-Dockerfile"><code>FROM ubuntu:latest
RUN apt-get update
RUN apt-get install -y nginx
EXPOSE 80
CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>该 Dockerfile 指定了使用最新版的 Ubuntu 作为基础镜像，并安装了 Nginx 服务器。它还将端口 80 暴露给外部，并在容器启动时运行 Nginx 服务器。</p><p>要使用 Dockerfile 构建 Docker 镜像，可以使用 <code>docker build</code> 命令。例如，假设 Dockerfile 文件在当前目录中，可以使用以下命令构建镜像：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$: <span class="token function">docker</span> build <span class="token parameter variable">-t</span> my-nginx-image <span class="token builtin class-name">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>该命令将使用当前目录中的 Dockerfile 文件构建名为&quot;my-nginx-image&quot;的 Docker 镜像。注意，最后一个 <strong>&quot;<code>.</code>&quot;</strong> 表示使用当前目录作为构建上下文。构建上下文是指构建镜像时 Docker 引擎可以访问到的文件和目录。</p><p>指令释义：</p><ol><li><p>FROM： 定制的镜像都是基于 FROM 的镜像，在定义基础镜像后，则都是基于自定义的镜像；</p></li><li><p>RUN：指令格式 <code>RUN &lt;命令行命令&gt;</code></p><p>两种命令格式：<code>shell</code> 和 <code>exec</code></p><ul><li><p>Shell 形式：<code>RUN &lt;command&gt;</code></p><ul><li>使用 <code>/bin/sh -c</code> 执行命令</li><li>可以使用 shell 内置的命令、管道和环境变量</li><li>构建时会创建一个新的 shell 进程并执行命令</li><li>适合复杂的操作和任务</li></ul></li><li><p>Exec 形式：<code>RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code></p><ul><li>直接执行可执行文件或脚本</li><li>不依赖于 shell 环境，因此更快且更安全</li><li>不支持一些 shell 特性，例如通配符扩展（wildcard expansion）、重定向（redirection）和变量替换（variable substitution）</li><li>适合简单的命令和操作</li></ul></li></ul></li></ol>`,25);function N(O,y){const s=m("ExternalLinkIcon");return g(),b("div",null,[v,o("p",null,[h,e(" 指令，可以查阅《"),o("a",D,[e("Systemd 入门教程：命令篇"),n(s)]),e("》。system 是一个 systemd 工具，主要负责控制 systemd 系统和服务管理器。诸如 timedatectl 等以 ctl 结尾的命令，其中 "),f,e("。")]),x,o("ul",null,[o("li",null,[e("手动下载图形化界面：如果你的电脑搭载的是 M1 芯片（"),_,e(" 架构），请点击以下 "),o("a",q,[e("链接"),n(s)]),e(" 下载 Docker Desktop for Mac。")])]),I])}const T=c(k,[["render",N],["__file","docker01.html.vue"]]);export{T as default};
