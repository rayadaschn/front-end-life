import{_ as c,V as l,W as i,X as n,Y as s,Z as a,$ as r,a0 as t,F as e}from"./framework-acd93724.js";const u={},d=n("h1",{id:"原型-原型链-new-的二三事",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#原型-原型链-new-的二三事","aria-hidden":"true"},"#"),s(" 原型-原型链-new 的二三事")],-1),k=n("p",null,"[toc]",-1),_=n("h2",{id:"_1-到底是什么",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#_1-到底是什么","aria-hidden":"true"},"#"),s(" 1. 到底是什么?")],-1),v=t(`<p><strong><code>new</code></strong> 关键字到底做了什么事情？</p><ul><li>首先创建一个空对象，这个空对象将会作为执行构造函数(<code>constructor</code>)之后的返回的对象实例。</li><li>对创建的空对象的原型(<code>newObj.__proto__</code>)指向构造函数的原型属性(<code>Function.prototype</code>)。</li><li>将这个空对象赋值给构造函数内部的 this，并执行构造函数逻辑。</li><li>依据构造函数执行逻辑，返回第一步所创建的对象或构造函数的显示返回值（必须是对象）。</li></ul><p>文字是苍白的，我们看看用代码如果来简单模拟一遍。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token keyword">new</span><span class="token punctuation">(</span><span class="token parameter">parentFn<span class="token punctuation">,</span> args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 1.新建一个空对象</span>
    <span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token comment">// 2.将新对象的__proto__属性赋值为构造函数的prototype指向的值</span>
    <span class="token comment">// 也可以用 obj.__proto__ = Object.create(parentFn.prototype) 实现</span>
    obj<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> parentFn<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
    <span class="token comment">// 3.在新对象的作用域下执行构造函数</span>
    <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token function">parentFn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 4.返回这个新对象,或构造函数显示返回值</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> result <span class="token operator">===</span> <span class="token string">&#39;object&#39;</span> <span class="token operator">&amp;&amp;</span> result <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> result <span class="token operator">:</span> obj
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面可以很清楚的看到，<code>new</code>把<code>构造函数</code>、<code>__proto__</code>和<code>prototype</code>三者联系起来了。</p><p>再来看一下 JavaScript Object Layout 的原图:</p><figure><img src="http://www.mollypages.org/tutorials/jsobj.jpg" alt="JavaScript Object Layout" tabindex="0" loading="lazy"><figcaption>JavaScript Object Layout</figcaption></figure>`,7),b={href:"http://www.mollypages.org/tutorials/js.mp",target:"_blank",rel:"noopener noreferrer"},m=t(`<p>简单梳理一下图中的定义关系和和需要记忆的关键点:</p><ul><li>构造函数是创建 <code>f1/f2</code> 对象的 <code>Foo( )</code>；</li><li>构造函数 <code>Foo( )</code>有一个原型对象叫 <code>Foo.prototype</code>，构造函数 <code>Foo( )</code>的 <strong><code>[[prototy]]</code></strong> 属性就指向它；</li><li>被构造函数 <code>Foo( )</code> 所创建的 <code>f1/f2</code> 对象有一个 <code>__proto__</code> 属性，它指向构造函数 Foo( )的原型对象 Foo.prototype；</li><li>原型对象 <code>Foo.prototype</code> 自身有一个特有属性 <code>constructor</code> 指回构造函数 <code>Foo( )</code>。</li></ul><p>我们对照图，来详细说说。构造函数 <code>Foo( )</code> 每次创建一个新的实例/对象的时候，实例/对象 中都有一个 <strong>[[prototy]]</strong> 的内部属性，它指向了构造函数 <code>Foo( )</code> 的原型对象( <code>Foo.prototype</code> )。<strong>关键点！</strong> <strong>关键点!！</strong> <strong>关键点!!！</strong> 这个 创建出来的 实例/对象的 <strong><code>[[prototy]]</code></strong> 内部属性该怎么访问它呢？现代浏览器中的 JS 引擎都用 <code>__proto__</code> 这个属性暴露出来。</p><p>然后再来看啊，构造函数 <code>Foo( )</code> 的<strong>原型对象( Foo.prototype )</strong>。 它叫原型对象是吧，它也是一个对象，是由 <strong>Object( )构造函数</strong>创建出来的! 所以它的<code>__proto__</code> 指向 <code>Object( )</code>构造函数的原型对象(<code>Object.prototype</code>)。<code>Object.prototype</code> 这个原型对象已经到头了，没有其它构造函数创建它了，所以指向 <code>null</code>。</p><p>再看啊，构造函数 Foo( ) 的<strong>原型对象( Foo.prototype )</strong> 的另一个关键点！这个原型对象除了因为 <code>__proto__</code> 这个原型链能够继承到 <code>Object</code>属性和方法外，还有一个重要的属性 <strong>[[constructor]]</strong> 。这个属性它指回 构造函数 Foo( )本身。</p><p>对关于 Object 构造函数其实也是这样，不再做说明。</p><p>最后，我们来看看 Foo 和 Function 的关系。</p><p>上面，我们看到 所有的 原型对象 都是由 <code>Object( )</code>构造函数创建的，而 Foo( ) 这样的构造函数呢？除去一个一个父级的构造函数套娃创建外（function Foo created via new Function），我们能最终看到它是最终被 Function 构造函数所创建。像 Object 这样的构造函数，也是被 最终的 Function 构造函数所创建。在图中我们可以看到，就连 Function 构造函数自己也是被自己所创建的（Function via new Function（so points to it’s own proto））。所以 它的 <code>__proto__</code> 指向自身的原型对象（实际上就是一个东西啦， <code>__proto__</code> 是被浏览器所造出来的东西）。</p><p>到这里，这张图，其实就解释的差不多了，然后，我们可以得到如下验证：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 定义一个构造函数 Foo()</span>
<span class="token keyword">function</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment">// 使用Foo创建一个实例</span>
<span class="token keyword">const</span> fooInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 三者之间的相互关系</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Foo</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {constructor: ƒ}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Foo</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Foo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fooInstance<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Foo</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后说点题外话，很多博主都是这样描述 <code>__proto__</code> 和 <strong><code>prototype</code></strong> 的：对象有 <code>__proto__</code> ，而函数还有一个 <strong><code>prototype</code></strong> 属性。这句话对，也不是很准确。明白其本质，才是理解的关键。笔者也是弯弯绕绕学了很多次，但是明白其本质原理，才是关键。想想 <code>new</code> 一个构造函数的过程，其实就知道这三者的关系啦。</p><h2 id="_2-原型链" tabindex="-1"><a class="header-anchor" href="#_2-原型链" aria-hidden="true">#</a> 2. 原型链</h2><p>从上面的原型一个接一个的 <code>__proto__</code> 的套用，所形成的链条，就是原型链。</p><p>我们来再来看看一些其它的知识（串串香呀(～￣ ▽ ￣)～）。</p><p>JS 的七大内置类型是： <u>Null、Undefined、Boolean、String、Number</u>、Object 和 Symbol。下划线的前五个是基本数据类型。</p><p>其中的 Object 又包含了 Function、Array 和 Date 等。（BigInt 作为一种新的数据类型，不做讨论）</p><p>检验数据类型的方法是 <strong>typeof</strong> ：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">typeof</span> <span class="token keyword">undefined</span> <span class="token operator">===</span> <span class="token string">&quot;undefined&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">typeof</span> <span class="token keyword">null</span> <span class="token operator">===</span> <span class="token string">&quot;object&quot;</span><span class="token punctuation">;</span> <span class="token comment">// 这个除外, 是一个 bug</span>
<span class="token keyword">typeof</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">&quot;object&quot;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，像 Function、Array 这些会输出 object，这并不是我们想要的。</p><p>解决办法：使用 instanceof 判断数据类型。利用原型链来搞定，<code>a instanceof B</code> 判断的是 <code>a</code> 的原型链是否存在 <code>B</code> 的构造函数。我们来手写一个 instanceof ：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">instanceofMock</span><span class="token punctuation">(</span><span class="token parameter">son<span class="token punctuation">,</span> parent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> son <span class="token operator">!==</span> <span class="token string">&quot;object&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 判断是否需要 instanceof 出手,不是 object 就是基本数据类型呀,用 typeof 判断</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>son <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 走到头了, 遍历到顶端也没有找到符合要求的原型链</span>
      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>son<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> parent<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    son <span class="token operator">=</span> son<span class="token punctuation">.</span>__proto__<span class="token punctuation">;</span> <span class="token comment">// 递归向上查找</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>【Tips】像 <code>996 instanceof Number !== true</code> 这种基本数据类型，它不是由 Number 构造函数直接创建的，结果返回是 flase，需要将数字包装一下： <code>new Number(955) instanceof Number === true</code></p></blockquote><p>好了，说回正题，我们来看看利用原型链来判断数据类型的终极方法：<code>Object.prototype.toString</code></p><p>但是，我们还是先来看个简单的调用:</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">955</span><span class="token punctuation">,</span> <span class="token number">955</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 955,955</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div>`,25),g={href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/toString",target:"_blank",rel:"noopener noreferrer"},f={href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array",target:"_blank",rel:"noopener noreferrer"},y=n("code",null,"Array",-1),h={href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object",target:"_blank",rel:"noopener noreferrer"},j=n("code",null,"Object",-1),w=n("code",null,"toString",-1),O=n("code",null,"toString",-1),F={href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/join",target:"_blank",rel:"noopener noreferrer"},S=n("code",null,"join()",-1),B=n("code",null,"join",-1),x={href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString",target:"_blank",rel:"noopener noreferrer"},A=n("code",null,"Object.prototype.toString",-1),N=n("code",null,"[object Array]",-1),E=t(`<div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
arr<span class="token punctuation">.</span>join <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// re-assign \`join\` with a non-function</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Logs [object Array]</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token function-variable function">join</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Logs 1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1),z=n("code",null,"Object.prototype.toString( )",-1),J=n("strong",null,[n("code",null,"toString()")],-1),C={href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2",target:"_blank",rel:"noopener noreferrer"},q=n("code",null,"toString",-1),L=n("code",null,"toString( )",-1),R=n("code",null,"Object.prototype.toString()",-1),W=n("code",null,'"[object Type]"',-1),D=n("code",null,"Type",-1),G=t(`<p>所以有了 <code>Object.prototype.toString.call( arr ) === &#39;[object Array]&#39;</code> 这样的方法来判断数据类型啦。</p><p>另外像 arr.valueOf( ) 实际上是 通过原型链进行查找: <code>arr.__proto__</code> 找到了数组 <code>Array ( )</code>构造函数，但是没有这个方法，所以继续向上查找。<code>arr.__proto__.__ proto__</code> 找到了 <code>Object.prototype</code> 上的 <code>valueOf( )</code> 方法，但是如果获取 <code>Object.prototype .valueOf( obj )</code> 所需要运行的 <code>obj</code> 内容呢。实际上 是做了 call 绑定，即 <code>arr.valueOf( ) </code> 等价于 <code>Object.prototype.valueOf.call( arr )</code>。也就是将 arr 传递给了 <code>valueOf</code> 方法了。我们可以进行简单验证:</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">955</span><span class="token punctuation">,</span> <span class="token number">955</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
arr<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [955, 955]</span>
arr<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">===</span> arr<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
arr<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">===</span> window<span class="token punctuation">.</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,3);function I(V,T){const p=e("RouterLink"),o=e("ExternalLinkIcon");return l(),i("div",null,[d,k,_,n("p",null,[s("笔者在 "),a(p,{to:"/JavaScript/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3this%E6%8C%87%E5%90%91.html"},{default:r(()=>[s("彻底理解 this 指向")]),_:1}),s(" 一文中，简单描述了 new 一个对象的过程。在此，再进行进一步的梳理。")]),v,n("p",null,[n("a",b,[s("原博文"),a(o)]),s(" 也推荐看一下噢,大体就能知道整个过程了。")]),m,n("p",null,[s("通过上面的原型链我们可以知道，数组为什么可以使用 Object 对象的 toString 方法，但是这里有几个小细节。通过 "),n("a",g,[s("MDN"),a(o)]),s(" 我们可以知道: “ "),n("a",f,[y,a(o)]),s(" 对象覆盖了 "),n("a",h,[j,a(o)]),s(" 的 "),w,s(" 方法。对于数组对象，"),O,s(" 方法在内部调用 "),n("a",F,[S,a(o)]),s(" 方法拼接数组中的元素并返回一个字符串，其中包含用逗号分隔的每个数组元素。如果 "),B,s(" 方法不可用，或者它不是一个函数，将使用 "),n("a",x,[A,a(o)]),s(" 代替，返回 "),N,s("。”")]),E,n("p",null,[s("再看看 "),z,s(" 的定义: "),J,s(" 方法返回一个表示该对象的字符串。该方法旨在重写（自定义）派生类对象的"),n("a",C,[s("类型转换"),a(o)]),s("的逻辑。也就是说每个对象都有一个"),q,s("方法，当对象被表示为一个文本值或一个字符串方式引用时，自动被调用。默认情况下，"),L,s("方法是被每个 Object 对象所继承，如果该方法未被自定义覆盖，"),R,s(" 就返回 "),W,s("，这里的 "),D,s(" 是对象的类型。")]),G])}const U=c(u,[["render",I],["__file","原型_原型链_new的二三事.html.vue"]]);export{U as default};
