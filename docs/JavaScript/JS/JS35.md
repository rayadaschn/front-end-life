---
title: 关于 Iterator 迭代器
icon: javascript
date: 2025-03-17
category:
  - javascript
tag:
  - javascript
sticky: false
---

迭代器的协议规范是：一个对象必须实现一个特定的接口，该接口包含一个名为 `next` 的方法，该方法返回一个对象，该对象包含两个属性：`value` 和 `done`。

`value` 属性表示迭代器返回的当前值，`done` 属性是一个布尔值，表示迭代器是否已经迭代完所有元素。

```js
{
  value: any,
  done: boolean
}
```

此外还需要实现 `Symbol.iterator` 方法，使得 `for...of`/解构/扩展运算符 等可以遍历该对象。

若数据结构(对象)具备了 `Symbol.iterator` 属性，则它就是可迭代的，可以被迭代器遍历。并且可以用 `for...of` 遍历。以**类数组**举例，默认是不具备 `Symbol.iterator` 属性的，所以不能被迭代器遍历，也不能用 `for...of` 遍历。(数组这个属性在原先上)

## 常见可迭代对象

- Array
- Map
- Set
- String
- TypedArray
- arguments 对象
- NodeList 对象

虽然类数组对象不具备 `Symbol.iterator` 属性，但是它们可以通过 `Array.from` 方法转换为数组，然后使用 `Symbol.iterator` 属性进行迭代。此外部分类数组也是具备这个原型方法的, 也具有 `length` 属性。但是它们不是纯数组, 不能直接使用 `map`、`filter` 等数组方法。如 `arguments`、`NodeList`、`HTMLCollection` 等。

```js
// node 节点，所有类型节点（Element、Text、Comment...），例如通过 document.querySelector('*') 获取的节点。这个是静态快照，后续节点更改，这个NodeList 不会改变。
NodeList.prototype[Symbol.iterator]

// 元素集合, 仅包含元素节点（Element），例如通过 document.getElementsByClassName('*') 获取的元素集合。动态实时更新，DOM 变化时自动同步
HTMLCollection.prototype[Symbol.iterator]
```

## js 简单实现

实现要点:

1. `next` 方法返回一个对象，该对象包含两个属性：`value` 和 `done`。
2. 当返回的 `done` 为 `true` 时，表示迭代器已经迭代完所有元素。
3. 需实现 `Symbol.iterator` 方法，使得 `for...of`/解构/扩展运算符 等可以遍历该对象。
4. 可维护状态，通过 `index` 记录当前遍历的位置。

```js
class Iterator {
  constructor(items = []) {
    this.items = items // 存储要遍历的元素
    this.index = 0 // 当前索引
  }

  next() {
    if (this.index < this.items.length) {
      return {
        value: this.items[this.index++],
        done: false,
      }
    } else {
      return {
        value: undefined,
        done: true,
      }
    }
  }

  // 为了支持 for...of 循环，我们需要在 Iterator 类中实现 Symbol.iterator 方法，该方法返回一个迭代器对象。迭代器对象需要实现 next 方法，该方法返回一个对象，包含 value 和 done 属性。value 是当前迭代的值，done 是一个布尔值，表示迭代是否结束。
  [Symbol.iterator]() {
    return this
  }
}

const iterator = new Iterator([10, 20, 30])

console.log(iterator.next()) // { value: 10, done: false }
console.log(iterator.next()) // { value: 20, done: false }
console.log(iterator.next()) // { value: 30, done: false }
console.log(iterator.next()) // { value: undefined, done: true }

// 支持 for...of
for (const val of new Iterator(['a', 'b', 'c'])) {
  console.log(val) // 输出 'a' 'b' 'c'
}
```

## 对象实现迭代

```js
Object.prototype[Symbol.iterator] = function () {
  // const keys = Object.keys(this)
  const keys = Reflect.ownKeys(this) // 相较于 Object.keys，Reflect.ownKeys 可以获取到不可枚举属性和 Symbol 属性。
  let index = 0 // 当前索引

  return {
    next: () => {
      if (index < keys.length) {
        return {
          value: this[keys[index++]],
          done: false,
        }
      } else {
        return {
          value: undefined,
          done: true,
        }
      }
    },
  }
}

const obj = { a: 1, b: 2, c: 3, [Symbol('sym')]: 4 }

for (const val of obj) {
  console.log(val) // 1, 2, 3, 4
}
```

## 关于 Reflect.ownKeys 的额外总结

| 方法                             | 能否获取 Symbol key                    |
| -------------------------------- | -------------------------------------- |
| `Object.keys()`                  | ❌ 只返回字符串 key                    |
| `Object.getOwnPropertyNames()`   | ❌ 只返回字符串 key                    |
| `for...in`                       | ❌ 只枚举字符串、可枚举 key            |
| `JSON.stringify()`               | ❌ 跳过 Symbol key                     |
| **`Reflect.ownKeys()`**          | ✅ 返回 **所有** key (字符串 + Symbol) |
| `Object.getOwnPropertySymbols()` | ✅ 只返回 Symbol key                   |

举例:

```js
const obj = { a: 1, b: 2, c: 3, [Symbol('sym')]: 4 }

Object.keys(obj) // 只返回字符串 key: ['a', 'b', 'c']

for (let key in obj) console.log(key) // 只打印 'a', 'b', 'c'

JSON.stringify(obj) // {"a":1,"b":2,"c":3}

Reflect.ownKeys(obj) // ['a', 'b', 'c', Symbol(sym)]

Object.getOwnPropertySymbols(obj) // [Symbol(sym)]
```

## 迭代运行的时间

关于运行效率，这里对比一下 for、while、for...of、for...in、forEach、map 的运行时间。

```js
const arr = new Array(1000000).fill(1)

console.time('for')
for (let i = 0; i < arr.length; i++) {}
console.timeEnd('for') // for: 2.17ms

console.time('while')
let i = 0
while (i < arr.length) {
  i++
}
console.timeEnd('while') // while: 1.141ms

console.time('for...of')
for (const val of arr) {
}
console.timeEnd('for...of') // for...of: 8.81ms

console.time('for...in')
for (const key in arr) {
}
console.timeEnd('for...in') // for...in: 87.847ms

console.time('forEach')
arr.forEach(() => {})
console.timeEnd('forEach') // forEach: 6.422ms

console.time('map')
arr.map(() => {})
console.timeEnd('map') // map: 7.874ms
```

可以看出 `for...in` 是最慢的，原因在于：`for...in` 会遍历所有可枚举属性，包括原型链上的可枚举属性，而其他方法只会遍历当前对象的属性。在实际开发中，因避免使用。
