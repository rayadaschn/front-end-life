---
title: Interview -- React 相关面试题
icon: note
date: 2022-08-12
category:
  - anonymous
tag:
  - note
star: false
# sticky: true
sticky: false
---

同 vue 一样，React 框架类面试主要考察三个方面:

- 框架的使用(基本使用, 高级特性, 周边插件)
- 框架的原理(基本原理的了解, 热门技术的深度和全面性)
- 框架的实际应用,即设计能力(组件结构和数据结构)

## 基本使用

### jsx 的基本使用

- 变量、表达式
- class style
- 子元素和组件
- 条件判断: `if else`、三元表达式和 逻辑运算符`&&`与`||`

### 事件

1. React 的事件函数需要进行 `this` 绑定，不绑定会出现 `this` 丢失的问题。或者使用箭头函数，则无需进行 `this` 绑定；

2. event 事件是 SyntheticEvent, 是模拟出来的 DOM 事件所有的能力；`event.nativeEvent` 是原生事件对象。在 React17 以前, 所有的事件都被挂载到 document 上，和 DOM 事件不一样，和 Vue 事件也不一样。 React17 后事件绑定到 root 组件上了，这样有利于多个 React 版本并存，例如微前端。

```js
import React from 'react'

export default class JsxBase extends React.Component {
  constructor(props) {
    super(props)
    this.state = {
      name: 'huy',
      age: 18,
      flag: true,
    }
  }
  render() {
    const exprElem = <p>{this.state.flag ? 'yes' : 'no'}</p>
    return (
      <div>
        {exprElem}
        <button onClick={this.clickHandel}>点击</button>
        <button onClick={this.clickHandel2}>点击事件</button>
      </div>
    )
  }
  clickHandel() {
    console.log(this) // undefined
  }
  clickHandel2(event) {
    event.preventDefault()
    event.stopPropagation()
    console.log('target', event.target) // 指向当前元素, 即当前元素触发
    console.log('current target', event.currentTarget) // 指向当前元素

    // 该 event 是 React 封装的
    console.log('event', event)
    console.log('event.__proto__.constructor', event.__proto__.constructor)

    // 原生事件是 event.nativeEvent
    console.log('nativeEvent', event.nativeEvent)
  }
}
```

### setState

> React <= 17 的版本中:
>
> - React 组件事件: 异步更新 + 会合并 state
> - DOM 事件 和 setTimeout 等: **同步更新**, 不会合并 state
>
> React 18 后
>
> - React 组件事件: 异步更新 + 会合并 state
> - DOM 事件 和 setTimeout 等: **异步更新**, 不会合并 state

特点:

- 不可变值(函数式编程, 纯函数)
- 可能是异步更新
- 可能会被合并

#### 不可变值的修改

```js
// 数组修改
const listCopy = this.state.list.slice() // 先拷贝一份出来, 再进行复运算
listCopy.splice(2, 0, 'insert string') // 中间插入/删除
this.setState({
  list1: this.state.list1.concat(10), // 追加
  list2: [...this.state.list2, 20], // 解构再追加
  list3: this.state.list3.slice(0, 2), // 截取
  list4: this.state.list4.filter((item) => item > 10), // 筛选
  list5: listCopy,
})

// 对象修改, 不可以直接对 obj 的属性进行修改, 这样是违法不可变值
this.setState({
  obj1: Object.assign({}, this.state.obj1, { a: 10 }),
  obj2: { ...this.state.obj2, a: 20 },
})
```

#### setState 同步/异步

在 React18 以前, 可能同步, 可能异步（只有 React 组件事件才批处理是异步的）

1. 直接修改是异步的;
2. 在 setState 的回调函数中是同步的;
3. 在 setTimeout 中是同步的;
4. 在自定义的 DOM 事件中是同步的;

```js
import React from 'react'

export default class SetStateTime extends React.Component {
  constructor(props) {
    super(props)
    this.state = {
      count: 0,
    }
  }
  render() {
    return (
      <div>
        <div>setState 渲染时机 同步/异步</div>
        <button onClick={this.add}>+</button>
      </div>
    )
  }
  add = () => {
    this.setState(
      {
        count: this.state.count + 1,
      },
      () => {
        console.log('同步: 回调函数中同步保留结果:', this.state.count)
      }
    )
    console.log('异步: count', this.state.count)

    setTimeout(() => {
      this.setState({
        count: this.state.count + 10,
      })
      console.log('同步: setTimeout 中是同步的', this.state.count)
    }, 0)
  }
  bodyClickHandler = () => {
    this.setState({
      count: this.state.count + 100,
    })
    console.log('同步: 在自定义的 DOM 事件中', this.state.count)
  }
  componentDidMount() {
    document.body.addEventListener('click', this.bodyClickHandler)
  }
  componentWillUnmount() {
    document.body.removeEventListener('click', this.bodyClickHandler)
  }
}
```

#### 可能会被合并

1. 直接连续修改会被合并更新
2. 在函数中是不会被合并更新的, 每一个都会执行, 因为函数式一个一个进行执行的

```js
// 直接连续修改, 会被合并, 以最后一个为主
this.setState({
  mergeCount: this.state.mergeCount + 1,
})
this.setState({
  mergeCount: this.state.mergeCount + 1,
})
this.setState({
  mergeCount: this.state.mergeCount + 1,
})

// 传入函数, 不会被合并(因为函数式一个一个执行的)
this.setState((preVState, props) => {
  return {
    mergeCount: preVState.mergeCount + 10,
  }
})
this.setState((preVState, props) => {
  return {
    mergeCount: preVState.mergeCount + 10,
  }
})
```

#### React 18 后的变化

加入了 Automatic Batching 自动批处理， 都变成异步更新了。

```js
import { useState, useEffect } from 'react'

export default function useSetSateTime() {
  const [value, setValue] = useState(100)

  const clickHandler = () => {
    setValue(value + 1)
    setValue(value + 1)
    console.log('异步更新', value)

    setTimeout(() => {
      setValue(value + 10)
      setValue(value + 10)
      console.log('setTimeout 依旧是异步更新', value)
    }, 0)
  }

  useEffect(() => {
    // 绑定 DOM 事件
    document.getElementById('btn2').addEventListener('click', () => {
      setValue(value + 100)
      setValue(value + 100)
      setValue(value + 100)
      console.log('自定义 DOM 事件还是异步更新', value)
    })
  })
  return (
    <div>
      <div>在 React 18 中全变为异步更新: {value}</div>
      <button onClick={clickHandler}>异步更新+</button>
      <button id="btn2">setTimeout +</button>
    </div>
  )
}
```

### 组件的生命周期

生命周期只存在于 类组件中，函数式组件中是用 hooks 来实现生命周期函数(useEffect 管理副作用)功能的。

- 挂载时: constructor -> render -> componentDidMount
- 更新时: (shouldComponentUpdate) -> render -> componentDidUpdate
- 卸载时: componentWillUnmount

父组件的生命周期和 Vue 一样的。

## 高级使用

知识点有: 函数组件、受控和非受控组件、ref、protals、context、异步组件（懒加载）、性能优化、shouldComponentUpdate、纯组件、不可变值 immutablejs、高阶组件、render prop 等。

### 受控组件和非受控组件

- 受控组件的值（例如 input 的 value）受 React 的 state 控制。
- 任何时候只要 state 发生变化，组件就会重新渲染，这样就可以确保用户界面和数据保持同步。
- 受控组件需要额外的代码来处理每个状态变化，以及处理用户输入。

  ```js
  <input type="text" value={this.state.value} onChange={this.handleChange} />
  ```

- 非受控组件的值不受 React 的 state 控制，而是由 DOM 本身管理。
- 在大多数情况下，非受控组件可能更简单，因为不需要处理每个状态变化，也不需要在组件中存储每个状态的值。

```js
class UncontrolledInput extends React.Component {
  constructor(props) {
    super(props)
    this.inputRef = React.createRef()
  }

  handleSubmit = (event) => {
    console.log('A name was submitted: ' + this.inputRef.current.value)
    event.preventDefault()
  }

  render() {
    return (
      <form onSubmit={this.handleSubmit}>
        <input type="text" ref={this.inputRef} />
        <button type="submit">Submit</button>
      </form>
    )
  }
}
```

> 优先使用受控组件，符合 React 设计原则，非受控组件的使用场景:
>
> 必须手动操作 DOM 元素, setState 实现不了, 如文件上传: `<input type=file />` ；
> 已及某些富文本编辑器， 需要传入 DOM 元素。

### Protals

> 使用场景: 处理一些兼容性的问题
>
> 1. 父组件 `overflow: hidden;` 子组件想要渲染出来;
> 2. 父组件 `z-index` 值太小;
> 3. fixed 需要放在 body 的第一层级。

Portal 是 React 16.3 版本引入的一个特性，它允许你在 DOM 树中的任何地方渲染子组件。传统的 React 组件渲染在组件的父组件的 DOM 节点中，但 Portal 可以将组件渲染到任何指定的 DOM 节点中。这对于创建弹出窗口、模态对话框、悬浮菜单等组件非常有用。

Portal 的使用方法很简单，只需要在组件的 `render` 方法中使用 `ReactDOM.createPortal` 函数：

```jsx
import ReactDOM from 'react-dom'

class MyPortalComponent extends React.Component {
  render() {
    return ReactDOM.createPortal(
      this.props.children,
      document.getElementById('portal-root')
    )
  }
}
```

在上面的例子中，`MyPortalComponent` 组件使用 `ReactDOM.createPortal` 函数将它的子组件渲染到 `id` 为 `portal-root` 的 DOM 节点中。这样，无论 `MyPortalComponent` 组件在 DOM 树中的什么位置，它的子组件都会被渲染到指定的 DOM 节点中。

Portal 是一个非常有用的特性，但是需要小心使用，因为它可以将组件渲染到任何地方，可能会导致一些不可预料的问题。

### context

Context 是一种跨组件传递数据的方式, 用于公共信息传递给各个组件，用 props 太过于繁琐，用 redux 过于重。 如定义一些主题等。

使用步骤:

1. 要使用 Context，首先需要创建一个 Context 对象：

   ```js
   const MyContext = React.createContext(defaultValue)
   ```

2. 使用 `MyContext.Provider` 组件在组件树中提供数据：

   ```jsx
   <MyContext.Provider value={value}> {/* 这里是子组件 */} </MyContext.Provider>
   ```

3. 在子组件中，可以使用 `MyContext.Consumer` 组件来消费数据：

   ```jsx
   <MyContext.Consumer> {value => /* 使用 value */} </MyContext.Consumer>
   ```

4. 或者在函数式组件中使用 `useContext` 钩子来消费数据：

   ```jsx
   import { useContext } from 'react'
   function MyComponent() {
     const value = useContext(MyContext) // 使用 value
   }
   ```

### 异步组件

在 Vue 中使用 `import()`，在 React 用使用 `React.lazy` 和 `React.Suspense`。

```jsx
const Child = React.lazy(() => import('./child'))

// 使用
class App extends React.Component {
  render() {
    return (
      <div>
        <React.Suspense fallback={<div>loading</div>}>
          <Child />
        </React.Suspense>
      </div>
    )
  }
}
```

## 框架原理

### React 组件如何通讯?

### JSX 的本质是什么

### context 是什么,有何用途

### shouldComponentUpdate 的用途是什么

### 描述 redux 单项数据流

```

```
